"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const class_validator_1 = require("class-validator");
const yup_1 = require("yup");
const CustomError_1 = require("../models/CustomError");
const CustomPrismaError_1 = require("../models/CustomPrismaError");
class ErrorHandler {
    handle(err, res, next, logger, ...callbacks) {
        if (logger)
            logger.error(`ErrorHandle::handle::${err.name}::${err.message}`);
        if (callbacks && callbacks.length > 0) {
            callbacks.forEach(callback => callback(err, res, next));
        }
        if (err instanceof CustomPrismaError_1.CustomPrismaError) {
            res.status(err.status).json(err.getErrorResponse());
        }
        else if (err instanceof CustomError_1.CustomError) {
            res.status(err.error.status).json(err.getErrorResponse());
        }
        else if (err instanceof yup_1.ValidationError) {
            const errors = err.errors.map((error) => ({
                code: err.name,
                message: error
            }));
            res.status(400).json({ errors });
        }
        else if (Array.isArray(err) && err[0] instanceof class_validator_1.ValidationError) {
            const errors = err.map((e) => {
                const messages = Object.keys(e.constraints).map(key => e.constraints[key]);
                return { code: "ValidationError", messages };
            });
            res.status(400).json({ errors });
        }
        else {
            res.status(500).json({
                errors: [
                    {
                        code: "E0001",
                        message: err.message
                    }
                ]
            });
        }
        next(err);
    }
}
exports.ErrorHandler = ErrorHandler;
//# sourceMappingURL=ErrorHandler.js.map